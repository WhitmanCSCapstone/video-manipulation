# File to translate .pde sketch files to quad objects
# ready for our program.
 
# Cleanup infile 
# Reorganize the file
# Indenting?
# conversion from cc[] to correct mappin - 
# Translated from midi lines - 

# Added absolute path
# Processing writes to map.csv
# Args input
# global variables
# better multiline in global comments
# writebufferlines
# added the midi hashmap
# removed drawing in setup
# fixed finding cc arrays and replacing with params

# If code is in controllerChange it will be ignored - Oh well.

import sys
import re
import os
from pathlib import Path
mypath = Path().absolute()


#https://stackoverflow.com/questions/68633/regex-that-will-match-a-java-method-declaration
func = re.compile(r'^[ \t]*(?:(?:public|protected|private)\s+)?(?:(static|final|native|synchronized|abstract|threadsafe|transient|(?:<[?\w\[\] ,&]+>)|(?:<[^<]*<[?\w\[\] ,&]+>[^>]*>)|(?:<[^<]*<[^<]*<[?\w\[\] ,&]+>[^>]*>[^>]*>))\s+){0,}(?!return)\b([\w.]+)\b(?:|(?:<[?\w\[\] ,&]+>)|(?:<[^<]*<[?\w\[\] ,&]+>[^>]*>)|(?:<[^<]*<[^<]*<[?\w\[\] ,&]+>[^>]*>[^>]*>))((?:\[\]){0,})\s+\b\w+\b\s*\(\s*(?:\b([\w.]+)\b(?:|(?:<[?\w\[\] ,&]+>)|(?:<[^<]*<[?\w\[\] ,&]+>[^>]*>)|(?:<[^<]*<[^<]*<[?\w\[\] ,&]+>[^>]*>[^>]*>))((?:\[\]){0,})(\.\.\.)?\s+(\w+)\b(?![>\[])\s*(?:,\s+\b([\w.]+)\b(?:|(?:<[?\w\[\] ,&]+>)|(?:<[^<]*<[?\w\[\] ,&]+>[^>]*>)|(?:<[^<]*<[^<]*<[?\w\[\] ,&]+>[^>]*>[^>]*>))((?:\[\]){0,})(\.\.\.)?\s+(\w+)\b(?![>\[])\s*){0,})?\s*\)(?:\s*throws [\w.]+(\s*,\s*[\w.]+))?')
midiInput = re.compile(r'(cc)')
javaPrimitives = {"byte", "short", "int", "long", "float", "double", "char", "boolean"}
processingAdditions = {"PImage","PVector","Capture","Movie","String","PFont","PApplet","PGraphics","Array","ArrayList","DoubleDict","DoubleList","HashMap","IntDict","IntList","Table","TableRow","BufferedReader","PrintWriter","PShader","PFont","AudioIn","Amplitude"}
typesToIgnore = {"Midi"}
validPrePrimitive = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-*+_~"

with open("processingPrimitives.txt",'r') as f:
    read = f.read()
# Reverse sort ensures that longer words are checked first
processingPrimitives = sorted(read.split("\n"),reverse = True)

# Loading substitutions for the cc array. 
# This file is generated by the pde file.
MidiMap = {}
try:
    with open("Map.csv","r") as f:
        mapFile = f.read()
        mapFile = mapFile.split("\n")
        for line in mapFile:
            t = line.split(",")
            if len(t) == 2:
                b,a = t
                MidiMap[a] = b
        foundMidiMap = True
except:
    print("No mapping file found! Double check Param mapping!")
    foundMidiMap = False

#Read input file to string
infile = ""
if len(sys.argv) == 2:
    fileToOpen = mypath / sys.argv[1]
else:
    print("Did not get path argument.")
    fileToOpen = mypath / "tempClass.pde"
print("Opening file: " + str(fileToOpen))
with open(fileToOpen,"r") as f:
    infile = f.read()
infile = infile.split("\n")

def findMidiInput(string):
    m = midiInput.search(string)
    return m

def isGlobalVariable(string,scope):
    return string.startswith(tuple(javaPrimitives.union(processingAdditions))) and scope == 0 and not containsFunction(string) and not "cc" in string

indentLevel = 0
def indent():
    global indentLevel
    return "\t" * indentLevel

def writeGlobalComments(f):
    """
        Currently just writes the comments until code is reached.
        Totally might break - Untested Multiline functionality.
    """
    inBody = False
    for line in infile:
        if line.startswith("/*"):
            f.write(line + "\n")
            if "*/" not in line:
                inBody = True
            continue
        if "*/" in line:
            f.write(line + "\n")
            inBody = False
        if inBody:
            f.write(line + "\n")
        elif len(removeComments(line)) > 1:
            f.write("\n")
            return
        else:
            f.write(line + "\n")
    
def containsFunction(string):
    m = func.search(string)
    return m

def removeComments(string):
    """
        String will not include newlines so
        /*xxxx*/ is the only way we will see a multiline.
    """
    lineComment = string.find("//")
    if lineComment != -1:
        string = string[:lineComment]
    while "/*" in string:
        sindex = string.find("/*")
        eindex = string.find("*/")
        if sindex < eindex:
            string = string[:sindex] + string[eindex+2:]
        else:
            break
    return string

def writeImports(f):
    toImport = []
    for line in infile:
        if line.startswith("import"):
            toImport.append(line)
    if len(toImport) > 0:
        f.write("//IMPORTS FOLLOW - Double check to make sure these are necessary!\n")
        for imp in toImport:
            f.write(imp + "\n")
        f.write("\n")
    

def writeGlobalFunctions(f):
    inFunction = False
    scopeDepth = 0
    for line in infile:
        noComments = removeComments(line)
        if "{" in noComments:
            scopeDepth += 1
        if "}" in noComments:
            scopeDepth -= 1
        if not inFunction and (scopeDepth == 0 or (scopeDepth == 1 and "{" in noComments)):
            if containsFunction(noComments):
                if not( "void setup()" in noComments or "void draw()" in noComments or "void controllerChange" in noComments):
                    inFunction = True
                    writeBufferline(f,"private "  + line)
                    #f.write("\tprivate " + line + "\n")
        elif inFunction:
            if scopeDepth == 0: #Found a }
                writeBufferline(f,line)
                f.write("\n")
                inFunction = False
            else:
                writeBufferline(f,line)

def writeClass(f):
    global indentLevel
    f.write("public class OutputQuad extends QuadObject{\n")
    indentLevel += 1
    writeFields(f)
    writeConstructor(f)
    writeRunSketch(f)
    indentLevel -= 1
    writeGlobalFunctions(f)
    f.write("}\n")

def writeFields(f):
    allGlobals = findGlobals()
    f.write(indent() + "private HashMap<String, Integer> map = MidiMapper.getSpecialButtons();\n")
    for globalVariable in allGlobals:
        line = globalVariable[0] + " " +  " ".join(globalVariable[1])
        f.write(indent() + "private " + line + "\n")
    f.write("\n")

def getSetup():
    setupStartIndex = -1
    setupEndIndex = -1
    setupLines = []
    inSetup = False
    scopeDepth = 0
    for i,line in enumerate(infile):
        if "void setup()" in removeComments(line[:]):
            setupStartIndex = i+1
            inSetup = True
            continue
        if "{" in removeComments(line[:]):
            scopeDepth += 1
        if "}" in removeComments(line[:]):
            scopeDepth -= 1
        if scopeDepth < 0:
            inSetup = False
            setupEndIndex = i
            break
        if inSetup:
            setupLines.append(line)
    return setupLines

def replaceThis(line):
    index = 0
    newLine = line[:]
    while index < len(newLine):
        split = newLine[index:]
        if split.startswith("//"):
            return newLine
        elif split.startswith("this"):
            #Check last character
            if index > 0: #Reverse flow protection
                if not newLine[index-1] in validPrePrimitive:
                    newLine = newLine[:index] + "app" + newLine[index+4:] 
                    index+=10
            else:
                newLine = newLine[:index] + "app" + newLine[index+4:] 
                index+=2
        index+=1
    return newLine

# Ensure that no drawing is happening in setup!
# It is bad for many reasons, but it will crash our main program
# regardless of what this code does. Also overwrites "this" with "app"
ignoreInSetup = ["fullScreen","noStroke","colorMode","size","background"]      
def writeConstructor(f):
    f.write(indent() + "OutputQuad(PApplet app, PGraphics buffer){\n")
    constructorBody = getSetup()
    for line in constructorBody:
        rc = removeComments(line)
        if any(ignore in rc for ignore in ignoreInSetup):
            continue
        if "this" in rc:
            line = replaceThis(rc)
        f.write(indent() + line + "\n")
    f.write(indent() + "}\n")
    f.write("\n")

def getDraw():
    drawStartIndex = -1
    drawEndIndex = -1
    drawLines = []
    inDraw = False
    scopeDepth = 0
    for i,line in enumerate(infile):
        if "void draw()" in removeComments(line[:]):
            drawStartIndex = i+1
            inDraw = True
            continue
        if "{" in removeComments(line[:]):
            scopeDepth += 1
        if "}" in removeComments(line[:]):
            scopeDepth -= 1
        if scopeDepth < 0:
            inDraw = False
            drawEndIndex = i
            break
        if inDraw:
            drawLines.append(line)
    return drawLines

def findAll(line,substring):
    indexes = []
    lastIndex = 0
    while lastIndex != -1:
        lastIndex = line.find(substring,lastIndex,len(line))
        if lastIndex == -1:
            break
        indexes.append(lastIndex)
        lastIndex += 1
    return indexes

def updateLine(line):
    # Adds tempBuffer. to necessary function calls.
    index = 0
    newLine = line[:]
    while index < len(newLine):
        split = newLine[index:]
        if split.startswith("//"):
            return newLine
        for keyword in processingPrimitives:
            if split.startswith(keyword):
                #Check last character
                if index > 0: #Reverse flow protection
                    if not newLine[index-1] in validPrePrimitive:
                        newLine = newLine[:index] + "tempBuffer." + newLine[index:] 
                        index+=10
                else:
                    newLine = newLine[:index] + "tempBuffer." + newLine[index:] 
                    index+=10
        index+=1
    return newLine


def writeBufferline(f,line):
    rc = removeComments(line)
    #matches = [(x,findAll(rc,x)) for x in processingPrimitives if x in rc]
    newstr = updateLine(line)
    f.write("\t" + newstr + "\n")

def writeRunSketch(f):
    global indentLevel
    f.write(indent() + "@Override\n")
    f.write(indent() + "protected void runSketch(Arraylist<Float> params){\n")
    indentLevel += 1
    f.write(indent() + "tempBuffer.beginDraw();\n")
    runSketchBody = getDraw()
    #Address indenting
    for line in runSketchBody:
        writeBufferline(f,line)

    f.write(indent() + "tempBuffer.endDraw();\n")
    indentLevel -= 1
    f.write(indent() + "}\n")
    f.write("\n")

def findGlobals():
    scope = 0
    globalsToAdd = []
    for line in infile:
        noComments = removeComments(line)
        noComments = noComments.lstrip()
        if "{" in noComments:
            scope+=1
        if "}" in noComments:
            scope -= 1
        #Get all possible keywords/separate Midi and global structs
        if isGlobalVariable(noComments,scope):
            globalsToAdd.append((line.split()[0],  line.split()[1:]))
    return globalsToAdd

def replaceCC(IRFile):
    with open("output.pde","w") as f:
        for line in IRFile:
            if findMidiInput(removeComments(line)):
                startIndex = line.find("cc")
                rParen = line[startIndex:].find("]")
                indexIn = line[startIndex+3:rParen+startIndex] #3 offsets cc[
                #Replace indexIn with Map value
                if foundMidiMap:
                    if indexIn.isdigit() and indexIn in MidiMap:
                        indexIn = '"' + MidiMap[indexIn] + '"'
                        composite = line[:startIndex] + "params.get(map.get(" + indexIn + "))" + line[rParen + startIndex + 1:]
                    else:
                        composite = line[:startIndex] + "params.get(" + indexIn + ")" + line[rParen + startIndex + 1:]
                f.write(composite + " // Replaced: " + line + "\n")
            elif "new Midi" in removeComments(line):
                f.write("\t\t//Deleted new Midi initialization\n")
            else:
                f.write(line + '\n')


def generateNewFile():
    with open("output.pde","w+") as f:
        writeGlobalComments(f)
        writeImports(f)
        writeClass(f)
    
    #Second pass to replace Midi cc array
    #Totally could have used truncate
    with open("output.pde","r+") as f:
        IRFile = f.read()
        IRFile = IRFile.split("\n")
        replaceCC(IRFile)
        

generateNewFile()